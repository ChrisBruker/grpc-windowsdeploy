# Using full_deploy Output in a Standalone CMake Project

This guide shows how to run the Conan `full_deploy` workflow and reuse the produced binaries in an independent CMake project that does **not** rely on Conan at configure time.

## 1. Generate the Deployable Package Set

Run the helper script from the repository root (it already configures MSVC with `vswhere`):

```powershell
.\conan_full_deploy_all.bat
```

The script executes `conan install` with the `full_deploy` deployer for the `Debug`, `RelWithDebInfo`, and `Release` build types. After it succeeds you will find a directory named `full_deploy/` with this structure:

```
full_deploy/
  bin/
    debug/
    relwithdebinfo/
    release/
  lib/
    debug/
    relwithdebinfo/
    release/
  include/
  proto/
  cmake/
    gRPCConfig.cmake
    gRPCTargets-<config>.cmake
    protobuf*
    ... other generated CMake files ...
```

The `cmake/` directory contains all the configuration files generated by `CMakeDeps`. These are the only files you need to integrate the deployed libraries into a CMake project without rerunning Conan.

## 2. Point CMake to the Deploy Location

Add the `cmake/` directory to `CMAKE_PREFIX_PATH` **before** invoking `find_package`. You can do this in your external project’s `CMakeLists.txt` or when invoking CMake from the command line.

### Option A: Inside `CMakeLists.txt`

```cmake
# Adjust this path so it points at the deployed cmake directory
list(APPEND CMAKE_PREFIX_PATH "${PROJECT_SOURCE_DIR}/path/to/full_deploy/cmake")

find_package(gRPC CONFIG REQUIRED)
find_package(protobuf CONFIG REQUIRED)
```

### Option B: Command Line (single config generators)

```powershell
cmake -S . -B build -DCMAKE_PREFIX_PATH="C:/path/to/full_deploy/cmake"
```

For multi-config generators such as Visual Studio, you can either set `CMAKE_PREFIX_PATH` in `CMakeLists.txt` as shown above or pass it through CMakePresets/toolchain files.

## 3. Link Against the Deployed Targets

Once `find_package` succeeds, link against the imported targets provided by the generated config files:

```cmake
add_executable(my_app src/main.cpp)

target_link_libraries(my_app
    PRIVATE
        grpc::grpc++
        grpc::grpc       # core C API if required
        protobuf::protobuf
)

target_include_directories(my_app PRIVATE
    "${CMAKE_PREFIX_PATH}/../include"   # headers deployed by full_deploy
)
```

> Tip: `${CMAKE_PREFIX_PATH}` may contain multiple entries; use `get_filename_component` or a cache variable if you need a single absolute path to the deploy directory.

## 4. Selecting the Correct Runtime Artifacts

The deployer separates binaries per configuration. When building your external project:

- If you compile in `Release`, CMake will automatically choose the `release/` libraries from `gRPCTargets-release.cmake`. The same applies to `Debug` and `RelWithDebInfo`.
- Copy the contents of `bin/<config>/` next to your executable or ensure they are discoverable at runtime (e.g., add to PATH).
- If you mix configurations (for example, building Debug while only deploying Release libraries) you will see linker errors. Regenerate the matching configuration with `conan_full_deploy_all.bat` in that case.

## 5. Updating the Deployment

Whenever you change the Conan recipe or need fresh binaries:

1. Delete the existing `full_deploy/` directory (optional but recommended to avoid stale files).
2. Rerun `.\conan_full_deploy_all.bat` to regenerate the packages and CMake configs.
3. Reconfigure your external CMake project so it reloads the updated `gRPCConfig.cmake` and targets.

With these steps you can ship or consume the generated gRPC binaries entirely outside of Conan, while still benefiting from Conan’s dependency graph and build management during the packaging phase.
